# -*- coding: utf-8 -*-

"""
/***************************************************************************
 FluxInsee
                                 A QGIS plugin
 Le plugin permet d'extraire les données de mobilités professionnelles et scolaires de l'INSEE
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2019-11-08
        copyright            : (C) 2019 by Romain Pellicier
        email                : r.pellicier@inddigo.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

__author__ = 'Romain Pellicier'
__date__ = '2019-11-08'
__copyright__ = '(C) 2019 by Romain Pellicier'

# This will get replaced with a git SHA1 when you do a git archive

__revision__ = '$Format:%H$'
import os
from qgis.PyQt.QtGui import QIcon
from qgis.PyQt.QtCore import QCoreApplication, QSettings

from qgis.core import (
    QgsProcessing,
    QgsProcessingAlgorithm,
    QgsProcessingParameterFeatureSource,
    QgsProcessingParameterFileDestination,
    QgsProviderRegistry,
    QgsProcessingException,
    QgsProcessingParameterProviderConnection,
    QgsProcessingParameterString
)

from .processing import run_full_processing
from .export_excel import export_detail_excel, export_synthese_excel

def sanitize_output_filename(path, default_name):
        # On récupère le dossier réel
        folder = os.path.dirname(path)

        # On force un nom propre
        filename = default_name

        return os.path.join(folder, filename)

class FluxInseeAlgorithm(QgsProcessingAlgorithm):

    INPUT = "INPUT"
    OUTPUT_DETAIL = "OUTPUT_DETAIL"
    OUTPUT_SYNTHESE = "OUTPUT_SYNTHESE"
    CONNEXION = "CONNEXION"

   

    # ---------- PARAMETRES ----------
    def initAlgorithm(self, config):
        self.addParameter(
            QgsProcessingParameterFeatureSource(
                self.INPUT,
                self.tr("Couche INSEE (OSM 4326 ou IGN 2154)"),
                [QgsProcessing.TypeVectorAnyGeometry]
            )
        )

        # Choix d'une connexion PostgreSQL QGIS
        self.addParameter(
                QgsProcessingParameterProviderConnection(
                    self.CONNEXION,
                    "Connexion PostgreSQL",
                    "postgres"
                )
            )
        self.addParameter(
            QgsProcessingParameterFileDestination(
                self.OUTPUT_DETAIL,
                self.tr("Fichier Excel - Détail"),
                "*.xlsx"
            )
        )

        self.addParameter(
            QgsProcessingParameterFileDestination(
                self.OUTPUT_SYNTHESE,
                self.tr("Fichier Excel - Synthèse"),
                "*.xlsx"
            )
        )

    # ---------- PARAMÈTRE CONNEXION ----------
    def _buildConnectionParameter(self):

        # récupérer les connexions PostgreSQL existantes
        md = QgsProviderRegistry.instance().providerMetadata("postgres")

        conns = md.connections().keys()

        last_conn = QSettings().value("flux_insee/last_connection", "")

        p = QgsProcessingParameterString(
            self.CONNEXION,
            self.tr("Connexion PostgreSQL"),
            defaultValue=last_conn,
            multiLine=False
        )
        p.setMetadata({
            "widget_wrapper": {
                "class": "processing.gui.wrappers_postgis.DbConnectionWidgetWrapper",
                "provider": "postgres"
            }
        })
        return p

    # ---------- PROCESS ----------
    def processAlgorithm(self, parameters, context, feedback):

        # ----------------------------------------------------------------------
        # 1. Lecture des paramètres
        # ----------------------------------------------------------------------
        layer = self.parameterAsSource(parameters, self.INPUT, context)
        connection_name = self.parameterAsString(parameters, self.CONNEXION, context)
        out_detail = self.parameterAsFileOutput(parameters, self.OUTPUT_DETAIL, context)
        out_synth = self.parameterAsFileOutput(parameters, self.OUTPUT_SYNTHESE, context)

        if not connection_name:
            raise QgsProcessingException("Aucune connexion PostgreSQL sélectionnée.")
        # ----------------------------------------------------------------------
        # 2. Vérification que la connexion pointe vers la base 'applicatifs'
        # ----------------------------------------------------------------------
        md = QgsProviderRegistry.instance().providerMetadata("postgres")
        conn_infos = md.findConnection(connection_name)

        if not conn_infos:
            raise QgsProcessingException("Connexion PostgreSQL invalide.")

        try:
            # Connexion DB "réelle"
            provider = QgsProviderRegistry.instance().providerMetadata("postgres")
            conn = provider.createConnection(connection_name)
            db_name = conn.executeSql("select current_database()")[0][0]
            feedback.pushInfo(f"Connexion PostgreSQL valide : base = {db_name}")

        except Exception as e:
            raise QgsProcessingException(f"Impossible de déterminer le nom de la base : {e}")

        # Test final
        if db_name != "applicatifs":
            raise QgsProcessingException(
                f"La connexion sélectionnée pointe vers la base <b>{db_name}</b> "
                f"au lieu de <b>applicatifs</b>.<br>"
                f"Veuillez sélectionner la connexion correcte."
            )

        # ----------------------------------------------------------------------
        # 3. Détection automatique des champs INSEE et NOM
        # ----------------------------------------------------------------------
        insee_field = self.detect_field(layer, ["insee", "insee_com"])
        nom_field = self.detect_field(layer, ["nom", "nom_commune"])

        if not insee_field or not nom_field:
            raise QgsProcessingException(
                "Impossible de détecter les champs INSEE et NOM dans la couche d’entrée.\n"
                f"Champs disponibles : {[f.name() for f in layer.fields()]}"
            )

        feedback.pushInfo(f"Champ INSEE détecté : {insee_field}")
        feedback.pushInfo(f"Champ NOM détecté : {nom_field}")

        # ----------------------------------------------------------------------
        # 4. Extraction des données territoriales
        # ----------------------------------------------------------------------
        territoires = [
            {"insee": str(f[insee_field]), "nom": str(f[nom_field])}
            for f in layer.getFeatures()
        ]

        if not territoires:
            raise QgsProcessingException("La couche ne contient aucun enregistrement.")

        # ----------------------------------------------------------------------
        # 5. Exécution du traitement SQL en base
        # ----------------------------------------------------------------------
        feedback.pushInfo("Lancement du traitement SQL…")

        queries_dt, queries_de = run_full_processing(
            connection_name,
            territoires,
            feedback
        )

        feedback.pushInfo("Traitement SQL terminé.")

        # ----------------------------------------------------------------------
        # 6. Correction automatique des extensions .xlsx
        # ----------------------------------------------------------------------
        if not out_detail.lower().endswith(".xlsx"):
            out_detail = sanitize_output_filename(out_detail, "flux_insee_detail.xlsx")

        if not out_synth.lower().endswith(".xlsx"):
            out_synth = sanitize_output_filename(out_synth, "flux_insee_synthese.xlsx")

        # ----------------------------------------------------------------------
        # 7. Export Excel (données en mémoire, sans requêtes PostgreSQL)
        # ----------------------------------------------------------------------
        feedback.pushInfo("Export Excel en cours…")

        export_detail_excel(queries_dt["detail"], queries_de["detail"], out_detail)
        export_synthese_excel(queries_dt["synthese"], queries_de["synthese"], out_synth)

        feedback.pushInfo("Export Excel terminé.")

        # ----------------------------------------------------------------------
        # 8. Ouvrir automatiquement le répertoire contenant les fichiers
        # ----------------------------------------------------------------------
        folder_detail = os.path.dirname(out_detail)
        folder_synth = os.path.dirname(out_synth)

        try:
            if folder_detail == folder_synth:
                os.startfile(folder_detail)
                feedback.pushInfo(f"Dossier ouvert : {folder_detail}")
            else:
                os.startfile(folder_detail)
                os.startfile(folder_synth)
                feedback.pushInfo(f"Dossiers ouverts : {folder_detail} et {folder_synth}")

        except Exception as e:
            feedback.pushInfo(f"Impossible d’ouvrir le dossier automatiquement : {e}")

        # ----------------------------------------------------------------------
        # 9. Sortie
        # ----------------------------------------------------------------------
        return {
            self.OUTPUT_DETAIL: out_detail,
            self.OUTPUT_SYNTHESE: out_synth
        }


    # ---------- UTIL ----------
    def detect_field(self, layer, possible_names):
        fields = [f.name().lower() for f in layer.fields()]
        for name in possible_names:
            if name.lower() in fields:
                return name
        return None

    # ---------- NOM / GROUPE ----------
    def group(self):
        return "Flux INSEE"

    def groupId(self):
        return "flux_insee"

    def name(self):
        return "calcul_flux_insee"

    def displayName(self):
        return self.tr("Calcul Flux INSEE")

    def tr(self, string):
        return QCoreApplication.translate("flux_insee", string)
    def createInstance(self):
        return FluxInseeAlgorithm()
    def shortHelpString(self):
        return self.tr("""
        <h3>Calcul des flux INSEE</h3>
        <p>
        Cet outil calcule les flux domicile-travail et domicile-études
        à partir d’une couche de communes.
        </p>

        <h4>Données d’entrée</h4>
        <ul>
            <li>Couche de communes : OSM, IGN ou couche des chefs-lieux <br>(les communes sélectionnées sont utilisées).</li>
            <li>Connexion PostgreSQL : sélectionner la base <b>"applicatifs" OBLIGATOIREMENT</b>.</li>
        </ul>

        <h4>Sorties</h4>
        <ul>
            <li>Fichier Excel Détail (.xlsx)</li>
            <li>Fichier Excel Synthèse (.xlsx)</li>
        </ul>
        <h4>Remarques</h4>
        <ul>
            <li>Vous pouvez laisser vides les dossiers de destination</li>
    """)